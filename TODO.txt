MOVE_ORDERING (v2.2)


CLEAN DU CODE (v2.1) :
    - Stocker les variables de la recherche dans du contexte pour tout factoriser exemples :
        typedef struct {
            PositionList *board_history;
            Move prio_move;
            int is_max; // On peut souvent déduire ça de la profondeur ou de la couleur
            char color;
        } SearchStack;
        typedef struct {
            TranspositionTable *tt;
            clock_t start_clk;
            double max_time;
            int *nodes;
            int max_depth;
        } SearchContext;
    - Pour de la perf : faire gaffe au cache. (Au pire demander à Gemini pour optimiser)
        -> stocker les enums dans des uint8_t par exemple
        -> stocker les moves dans des uint16_t (big taffe mais cool)
    - Peut être? Ne pas se trimbaler l'historique partout et utiliser uniquement une table d'historique
    - Improve l'UCI avec des options supplémentaires



// Historique des changements

v2.1.6 In place board change

v2.1.5b Fix Quiescence search
    - déjà j'avais pas aggrandi la taille de TT au bon endroit (dans mega tt), c'était toujours 2^20 et pas 2^22, c'est fix
    - la quiescence search marchait juste pas, parce que mon if sur si yavait des prises était cassé (on prenait les attaques de l'ennemi & pièces ennemies, au lieu d enos attaques)
    - la partie alphabeta pruning à la fin cassait tout, je sais tjs pas pk. En le retirant j'ai eu +170.0 +/- 71.1 elo sur 100 parties
        -> + 186.8 +/- 21.2 elo le total
        -> on peut en profiter pour vérifier la TT, +x elo la TT, +x elo de 2^20 à 2^24

v2.1.5 Quiescence search (À AMÉLIORER SUREMENT)
    - bugfix sur le castling (les prises des tour retirent les droits)
    - Implémentation de la quiescence search
    - On évalue chaque position jusqu'à ce qu'il n'y ait plus de captures possible
    - On cut la quiescence dans un certain nombre de cas.
    - TODO: la quiescence pour échecs et promotions, vérifier si y a pas des bugs car gains elos assez peu fous
        -> +19.4 +/- 20.0

v2.1.4 Killer Moves
    - Big fix du move ordering, j'avais oublié de l'implémenter pour l'adversaire
        -> + 129.8 +/- 64.7
    - Ajout des killers moves (moves qui provoquent un cutoff sur les branches cousines de la même depth, priorisé dans le move order car a des chances d'être un bon coup qui provoque un cutoff une nouvelle fois)
        -> + 51.6 +/- 41.6 elo par rapport au debug
        -> Total +187.0 +/- 29.6 elo !!!


v2.1.3 Move ordering
    - eh gros sayer
    - On ajoute un score à chaque coup généré en fonction des prises 
      (ou un score de fou si c'est le meilleur coup de la TT avec moins de profondeur ou le coup de l'iterative deepening)
    - Comme ça on prend toujours le move de la tt en premier même si la profondeur est nulle
    - Ensuite, pendant le parcourt de la boucle pour chercher dans les mouvements, on fait du tri par insertion (on insère le meilleur coup comme prochain coup à parcourir en alphabeta)
        -> +98.2 +/- 19.0 elo

v2.1.2 no malloc +tt
    - retirer les mallocs inutiles dans la boucle alphabeta (positionList et moveList)
        -> -4.6 +/- 17.0 elo, dommage, mais je garde ça change ratio
    - augmentation de la taille de la tt (1<<20 -> 1<<24), en réduisant la taille des ttentries (uint8_t/15_t...).
        -> Complètement nul.

v2.1.1 legaclean (+4.8 +/- 22.8 elo)
    - retirage de plein de fonctions legacy plus utilisée (logique de base pour move generation et 3fold repetirion)
        -> Pas de gain elo supposé. Sur 500 test on a +4.8 +/- 22.8 elo donc ok.

v2.1.0 no char (+15.5 +/- 11.9 elo)
    - stocker les enums dans des uint8_t
    - Changer partout les types de couleurs et pièce from char to leur enum correspondante.

TODO CLEAN DU CODE (v2.1) :
    - Changer partout les types de couleurs et pièce from char to leur enum correspondante
    - Stocker les variables de la recherche dans du contexte pour tout factoriser exemples :
        typedef struct {
            PositionList *board_history;
            Move prio_move;
            int is_max; // On peut souvent déduire ça de la profondeur ou de la couleur
            char color;
        } SearchStack;
        typedef struct {
            TranspositionTable *tt;
            clock_t start_clk;
            double max_time;
            int *nodes;
            int max_depth;
        } SearchContext;
    - Pour de la perf : faire gaffe au cache. (Au pire demander à Gemini pour optimiser)
        -> stocker les enums dans des uint8_t par exemple
        -> stocker les moves dans des uint16_t (big taffe mais cool)
    - Peut être? Ne pas se trimbaler l'historique partout et utiliser uniquement une table d'historique
    - Improve l'UCI avec des options supplémentaires


v2.0.5 TranspositionTable (+101.8 +/- 13.5 elo, draw ratio 25.3%)
    - Ajout d'une transposition table de base, +13.6 +/- 2.3 fakeelo, mais 78% draw ratio
    - Considération de nulle au bout d'une seule répétition mais -21.5 +/- 5.9 fakeelo, et 19.5% de draw ratio
    - Avec une éval à -200 sur la 3fold repetition : 110.5 +/- 2.9 fakeelo, 61.3% de draw ratio
  => Je viens de me rendre compte qu'avant avec CuteChess, j'avais 0.1s de time par game, au lieu de 10+0.1. Du coup les évals sont pas bonnes
    - Retour des évals de structure de pions et de roque (16.0 +/- 9.5 elo)
    - On ne considère PAS les nulles dans les transpos tables, même quand on les récupère (ça pourra être utile pour le move ordering par contre)
        -> +46.5 +/- 10.0 elo
    - 

v2.0.4 Depth extension
    - Ajout d'une depth extention jusqu'à +8 en cas d'échec
        -> +14.0 +/- 3.4 fakeelo
    - Utilisation de CuteChess pour évaluer le fakeelo -> retirage de Pwn structure et rock eval
        -> gain total 2.0.4 : 43.4 +/- 4.2 fakeelo

v2.0.3 Pwn sructure
    - Évaluation pwn structure  (-3.8 +/- 4.7 fakeelo)
    - Évaluation rock           (-6.7 +/- 5.2 fakeelo)


v2.0.2 Time Control
    - (Big changement de l'éval vers PeSTO, je sais pas exactement quand c'est)
    - Changement du time control pour être réellement fiable avec l'UCI (ajout du handling de winc)

BASE LEGACY v2.0.x