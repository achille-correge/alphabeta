MOVE_ORDERING (v2.2)


CLEAN DU CODE (v2.1) :
    - Stocker les variables de la recherche dans du contexte pour tout factoriser exemples :
        typedef struct {
            PositionList *board_history;
            Move prio_move;
            int is_max; // On peut souvent déduire ça de la profondeur ou de la couleur
            char color;
        } SearchStack;
        typedef struct {
            TranspositionTable *tt;
            clock_t start_clk;
            double max_time;
            int *nodes;
            int max_depth;
        } SearchContext;
    - Pour de la perf : faire gaffe au cache. (Au pire demander à Gemini pour optimiser)
        -> stocker les enums dans des uint8_t par exemple
        -> stocker les moves dans des uint16_t (big taffe mais cool)
    - Peut être? Ne pas se trimbaler l'historique partout et utiliser uniquement une table d'historique
    - Improve l'UCI avec des options supplémentaires



// Historique des changements

v2.1.3 Move ordering
    - eh gros sayer
    - On ajoute un score à chaque coup généré en fonction des prises

v2.1.2 no malloc +tt
    - retirer les mallocs inutiles dans la boucle alphabeta (positionList et moveList)
        -> -4.6 +/- 17.0 elo, dommage, mais je garde ça change ratio
    - augmentation de la taille de la tt (1<<20 -> 1<<24), en réduisant la taille des ttentries (uint8_t/15_t...).
        -> Complètement nul.

v2.1.1 legaclean (+4.8 +/- 22.8 elo)
    - retirage de plein de fonctions legacy plus utilisée (logique de base pour move generation et 3fold repetirion)
        -> Pas de gain elo supposé. Sur 500 test on a +4.8 +/- 22.8 elo donc ok.

v2.1.0 no char (+15.5 +/- 11.9 elo)
    - stocker les enums dans des uint8_t
    - Changer partout les types de couleurs et pièce from char to leur enum correspondante.

TODO CLEAN DU CODE (v2.1) :
    - Changer partout les types de couleurs et pièce from char to leur enum correspondante
    - Stocker les variables de la recherche dans du contexte pour tout factoriser exemples :
        typedef struct {
            PositionList *board_history;
            Move prio_move;
            int is_max; // On peut souvent déduire ça de la profondeur ou de la couleur
            char color;
        } SearchStack;
        typedef struct {
            TranspositionTable *tt;
            clock_t start_clk;
            double max_time;
            int *nodes;
            int max_depth;
        } SearchContext;
    - Pour de la perf : faire gaffe au cache. (Au pire demander à Gemini pour optimiser)
        -> stocker les enums dans des uint8_t par exemple
        -> stocker les moves dans des uint16_t (big taffe mais cool)
    - Peut être? Ne pas se trimbaler l'historique partout et utiliser uniquement une table d'historique
    - Improve l'UCI avec des options supplémentaires


v2.0.5 TranspositionTable (+101.8 +/- 13.5 elo, draw ratio 25.3%)
    - Ajout d'une transposition table de base, +13.6 +/- 2.3 fakeelo, mais 78% draw ratio
    - Considération de nulle au bout d'une seule répétition mais -21.5 +/- 5.9 fakeelo, et 19.5% de draw ratio
    - Avec une éval à -200 sur la 3fold repetition : 110.5 +/- 2.9 fakeelo, 61.3% de draw ratio
  => Je viens de me rendre compte qu'avant avec CuteChess, j'avais 0.1s de time par game, au lieu de 10+0.1. Du coup les évals sont pas bonnes
    - Retour des évals de structure de pions et de roque (16.0 +/- 9.5 elo)
    - On ne considère PAS les nulles dans les transpos tables, même quand on les récupère (ça pourra être utile pour le move ordering par contre)
        -> +46.5 +/- 10.0 elo
    - 

v2.0.4 Depth extension
    - Ajout d'une depth extention jusqu'à +8 en cas d'échec
        -> +14.0 +/- 3.4 fakeelo
    - Utilisation de CuteChess pour évaluer le fakeelo -> retirage de Pwn structure et rock eval
        -> gain total 2.0.4 : 43.4 +/- 4.2 fakeelo

v2.0.3 Pwn sructure
    - Évaluation pwn structure  (-3.8 +/- 4.7 fakeelo)
    - Évaluation rock           (-6.7 +/- 5.2 fakeelo)


v2.0.2 Time Control
    - (Big changement de l'éval vers PeSTO, je sais pas exactement quand c'est)
    - Changement du time control pour être réellement fiable avec l'UCI (ajout du handling de winc)

BASE LEGACY v2.0.x